{
  "language": "Solidity",
  "sources": {
    "contracts/SSI/DIDRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * @title DID Registry\n * @notice A decentralized registry for Decentralized Identifiers (DIDs) on Ethereum\n * @dev This contract implements Phase 2 of the SSI learning path - DID Registry\n * \n * WHAT THIS CONTRACT DOES:\n * - Registers DIDs (Decentralized Identifiers) on-chain\n * - Associates Ethereum addresses with DIDs\n * - Stores DID Document hashes (not full documents for gas efficiency)\n * - Allows DID owners to update their DID Document hash\n * - Enables DID resolution (looking up a DID to get its document hash)\n * \n * WHY WE NEED THIS:\n * 1. Decentralization: No single entity controls identity registration\n * 2. Immutability: Once registered, DID ownership can't be falsified\n * 3. Verifiability: Anyone can verify who owns a DID\n * 4. On-chain Resolution: Smart contracts can resolve DIDs to documents\n * \n * HOW IT WORKS:\n * - Each DID is associated with an Ethereum address (the DID controller)\n * - DID Documents are stored off-chain (IPFS, databases, etc.)\n * - Only the hash of the DID Document is stored on-chain (saves gas)\n * - The hash allows verification that a DID Document hasn't been tampered with\n * \n * LEARNING NOTES:\n * - This is a simplified DID registry for learning purposes\n * - Real-world DID registries may have additional features (key rotation, service endpoints, etc.)\n * - We use the \"ethr\" DID method (did:ethr:0x...)\n */\ncontract DIDRegistry {\n    /**\n     * @notice Emitted when a new DID is registered\n     * @param did The Decentralized Identifier (e.g., \"did:ethr:0x123...\")\n     * @param controller The Ethereum address that controls this DID\n     * @param documentHash The hash of the DID Document (for verification)\n     * @param documentURI The location where the DID Document can be fetched\n     * \n     * WHY WE EMIT EVENTS:\n     * - Events are cheaper than storage (for historical data)\n     * - Frontend apps can listen to events for real-time updates\n     * - Events provide a searchable history of DID registrations\n     * - documentURI in event allows off-chain indexing without querying storage\n     */\n    event DIDRegistered(\n        string indexed did,\n        address indexed controller,\n        bytes32 documentHash,\n        string documentURI\n    );\n\n    /**\n     * @notice Emitted when a DID Document is updated\n     * @param did The DID being updated\n     * @param newDocumentHash The new hash of the DID Document\n     * @param newDocumentURI The new location of the DID Document\n     * @param previousDocumentHash The previous hash (for tracking changes)\n     * \n     * WHY ALLOW UPDATES:\n     * - DID Documents may need to be updated (new keys, new services)\n     * - The hash changes when the document changes\n     * - The URI may change if document is moved to new location\n     * - We track both old and new values for audit purposes\n     */\n    event DIDDocumentUpdated(\n        string indexed did,\n        bytes32 newDocumentHash,\n        string newDocumentURI,\n        bytes32 previousDocumentHash\n    );\n\n    /**\n     * @notice Emitted when DID ownership is transferred\n     * @param did The DID being transferred\n     * @param previousController The previous owner\n     * @param newController The new owner\n     * \n     * WHY ALLOW TRANSFERS:\n     * - Users may want to migrate to a new wallet\n     * - Organizations may transfer DID control\n     * - Important for DID recovery scenarios\n     */\n    event DIDOwnershipTransferred(\n        string indexed did,\n        address indexed previousController,\n        address indexed newController\n    );\n\n    /**\n     * @dev Structure to store DID information\n     * \n     * WHY THIS STRUCTURE:\n     * - controller: The Ethereum address that owns/controls this DID\n     * - documentHash: Hash of the DID Document (for verification)\n     * - documentURI: Location where the DID Document can be fetched (IPFS CID, HTTP URL, etc.)\n     * - registeredAt: Timestamp of registration (useful for analytics)\n     * - updatedAt: Last update timestamp (for tracking changes)\n     * \n     * WHY STORE documentURI:\n     * - CRITICAL: Without this, resolvers don't know WHERE to fetch the document!\n     * - Enables complete DID resolution: hash tells you WHAT to verify, URI tells you WHERE to get it\n     * - Can store IPFS CID (ipfs://Qm...), HTTP URL (https://...), or any URI format\n     * \n     * TRADE-OFF:\n     * - Costs extra gas (~20,000 gas for string storage)\n     * - But enables direct on-chain resolution without off-chain infrastructure\n     * - Alternative: Store URI in events (cheaper but requires indexing)\n     * \n     * WHY STORE TIMESTAMPS:\n     * - Useful for auditing and compliance\n     * - Can be used to detect suspicious activity\n     * - Helps with credential expiration logic\n     */\n    struct DIDRecord {\n        address controller;        // Who controls this DID\n        bytes32 documentHash;      // Hash of the DID Document (for verification)\n        string documentURI;        // Where to fetch the DID Document (e.g., \"ipfs://Qm...\" or \"https://...\")\n        uint256 registeredAt;      // When was this DID registered\n        uint256 updatedAt;         // When was it last updated\n    }\n\n    /**\n     * @dev Mapping from DID string to DIDRecord\n     * \n     * WHY USE MAPPING:\n     * - O(1) lookup time (very efficient)\n     * - Easy to check if a DID exists (check if controller != address(0))\n     * - Gas efficient for reads\n     * \n     * STORAGE COST:\n     * - Each DID record costs ~20,000 gas to store\n     * - Reading costs ~2,100 gas (warm) or ~100 gas (cold)\n     */\n    mapping(string => DIDRecord) private _dids;\n\n    /**\n     * @dev Mapping from controller address to DID\n     * \n     * WHY THIS MAPPING:\n     * - Allows reverse lookup: \"What DID does this address control?\"\n     * - Useful for frontend: \"Show me my DID\"\n     * - Enables one-address-to-one-DID relationship (simplified for learning)\n     * \n     * NOTE: In real-world, one address might control multiple DIDs\n     * This is simplified for learning purposes\n     */\n    mapping(address => string) private _controllerToDID;\n\n    /**\n     * @notice Registers a new DID\n     * @param did The Decentralized Identifier (must follow format: \"did:ethr:0x...\")\n     * @param documentHash The hash of the DID Document (SHA-256 recommended)\n     * @param documentURI The location where the DID Document can be fetched\n     *                    Examples: \"ipfs://QmXoypizj...\" or \"https://example.com/did-docs/123\"\n     * \n     * @dev Requirements:\n     * - DID must not already be registered\n     * - Caller must not already control a DID\n     * - DID format should be validated (simplified here for learning)\n     * - documentURI should not be empty (enables resolution)\n     * \n     * HOW IT WORKS:\n     * 1. Check if DID already exists (revert if yes)\n     * 2. Check if caller already has a DID (revert if yes - simplified)\n     * 3. Validate documentURI is not empty (critical for resolution)\n     * 4. Store the DID record (including hash AND URI)\n     * 5. Store reverse mapping (address -> DID)\n     * 6. Emit event for frontend/off-chain systems\n     * \n     * COMPLETE RESOLUTION FLOW:\n     * 1. Resolver calls resolveDID() → gets documentHash and documentURI\n     * 2. Resolver fetches document from documentURI (IPFS, HTTP, etc.)\n     * 3. Resolver hashes the fetched document\n     * 4. Resolver compares: fetched hash == documentHash? → Authentic!\n     * \n     * GAS COST: ~70,000 - 90,000 gas (depending on DID and URI string lengths)\n     * \n     * SECURITY CONSIDERATIONS:\n     * - Only the caller can register a DID for themselves\n     * - No one can register a DID for someone else\n     * - DID format validation is simplified (add more checks in production)\n     * - documentURI should point to immutable content (IPFS) or trusted source\n     */\n    function registerDID(\n        string memory did,\n        bytes32 documentHash,\n        string memory documentURI\n    ) external {\n        // WHY CHECK: Prevent overwriting existing DIDs\n        // This ensures DID uniqueness (critical for identity systems)\n        require(\n            _dids[did].controller == address(0),\n            \"DIDRegistry: DID already registered\"\n        );\n\n        // WHY CHECK: Simplified - one address = one DID\n        // In production, you might allow multiple DIDs per address\n        require(\n            bytes(_controllerToDID[msg.sender]).length == 0,\n            \"DIDRegistry: Address already has a DID\"\n        );\n\n        // WHY CHECK: documentURI is critical - without it, resolvers can't fetch the document!\n        // This solves the \"chicken and egg\" problem you identified\n        require(\n            bytes(documentURI).length > 0,\n            \"DIDRegistry: documentURI cannot be empty\"\n        );\n\n        // WHY STORE TIMESTAMP: Useful for auditing and analytics\n        uint256 timestamp = block.timestamp;\n\n        // Store the DID record\n        // WHY STRUCT: Groups related data together, easier to manage\n        _dids[did] = DIDRecord({\n            controller: msg.sender,        // The caller owns this DID\n            documentHash: documentHash,   // Hash of document (for verification)\n            documentURI: documentURI,     // Where to fetch the document (IPFS, HTTP, etc.)\n            registeredAt: timestamp,      // When registered\n            updatedAt: timestamp          // Initially same as registered\n        });\n\n        // Store reverse mapping for efficient lookup\n        // WHY: Allows \"what DID does this address control?\" queries\n        _controllerToDID[msg.sender] = did;\n\n        // WHY EMIT EVENT: Cheaper than storage, enables off-chain indexing\n        // Includes documentURI so indexers can build DID → Location databases\n        emit DIDRegistered(did, msg.sender, documentHash, documentURI);\n    }\n\n    /**\n     * @notice Updates the DID Document for an existing DID\n     * @param did The DID to update\n     * @param newDocumentHash The new hash of the DID Document\n     * @param newDocumentURI The new location of the DID Document (can be same as before)\n     * \n     * @dev Requirements:\n     * - DID must exist\n     * - Caller must be the DID controller\n     * - newDocumentURI must not be empty\n     * \n     * WHY ALLOW UPDATES:\n     * - DID Documents may need updates (add new keys, services)\n     * - When document changes, hash changes\n     * - Document may be moved to new location (new IPFS CID, etc.)\n     * - This allows DID evolution without re-registration\n     * \n     * USE CASES:\n     * - Adding a new public key for authentication\n     * - Adding a service endpoint (e.g., credential wallet)\n     * - Updating recovery mechanisms\n     * - Moving document to new storage location\n     * \n     * SECURITY:\n     * - Only the controller can update\n     * - Old hash is preserved in event for audit trail\n     * - Both hash and URI are updated atomically\n     */\n    function updateDIDDocument(\n        string memory did,\n        bytes32 newDocumentHash,\n        string memory newDocumentURI\n    ) external {\n        // WHY CHECK: Ensure DID exists\n        DIDRecord storage record = _dids[did];\n        require(\n            record.controller != address(0),\n            \"DIDRegistry: DID does not exist\"\n        );\n\n        // WHY CHECK: Only controller can update\n        // This is critical for security - prevents unauthorized changes\n        require(\n            record.controller == msg.sender,\n            \"DIDRegistry: Only controller can update\"\n        );\n\n        // WHY CHECK: documentURI is required for resolution\n        require(\n            bytes(newDocumentURI).length > 0,\n            \"DIDRegistry: documentURI cannot be empty\"\n        );\n\n        // WHY STORE OLD HASH: For audit trail and event emission\n        bytes32 previousHash = record.documentHash;\n\n        // Update both hash and URI atomically\n        // WHY ATOMIC: Ensures hash and URI always match\n        record.documentHash = newDocumentHash;\n        record.documentURI = newDocumentURI;\n        record.updatedAt = block.timestamp;\n\n        // WHY EMIT EVENT: Track all updates for auditing\n        emit DIDDocumentUpdated(did, newDocumentHash, newDocumentURI, previousHash);\n    }\n\n    /**\n     * @notice Transfers DID ownership to a new address\n     * @param did The DID to transfer\n     * @param newController The new controller address\n     * \n     * @dev Requirements:\n     * - DID must exist\n     * - Caller must be current controller\n     * - New controller must not already have a DID (simplified)\n     * \n     * WHY ALLOW TRANSFERS:\n     * - Users may migrate to new wallets\n     * - Organizations may transfer control\n     * - Important for DID recovery scenarios\n     * \n     * SECURITY CONSIDERATIONS:\n     * - Only current controller can transfer\n     * - Consider adding a delay/confirmation for production\n     * - Consider multi-sig for important DIDs\n     */\n    function transferDIDOwnership(string memory did, address newController)\n        external\n    {\n        // WHY CHECK: Ensure DID exists\n        DIDRecord storage record = _dids[did];\n        require(\n            record.controller != address(0),\n            \"DIDRegistry: DID does not exist\"\n        );\n\n        // WHY CHECK: Only controller can transfer\n        require(\n            record.controller == msg.sender,\n            \"DIDRegistry: Only controller can transfer\"\n        );\n\n        // WHY CHECK: Prevent overwriting (simplified - one DID per address)\n        require(\n            bytes(_controllerToDID[newController]).length == 0,\n            \"DIDRegistry: New controller already has a DID\"\n        );\n\n        // WHY STORE OLD CONTROLLER: For event emission\n        address previousController = record.controller;\n\n        // Update reverse mapping\n        delete _controllerToDID[previousController];\n        _controllerToDID[newController] = did;\n\n        // Transfer ownership\n        record.controller = newController;\n        record.updatedAt = block.timestamp;\n\n        // WHY EMIT EVENT: Track ownership changes\n        emit DIDOwnershipTransferred(did, previousController, newController);\n    }\n\n    /**\n     * @notice Resolves a DID to its record\n     * @param did The DID to resolve\n     * @return controller The address that controls this DID\n     * @return documentHash The hash of the DID Document (for verification)\n     * @return documentURI The location where the DID Document can be fetched\n     * @return registeredAt When the DID was registered\n     * @return updatedAt When the DID was last updated\n     * \n     * WHAT IS DID RESOLUTION:\n     * - The process of looking up a DID to get its information\n     * - Similar to DNS lookup (domain name -> IP address)\n     * - Here: DID -> DID Document hash, URI, and controller\n     * \n     * COMPLETE RESOLUTION FLOW:\n     * 1. Call resolveDID() → Get documentHash and documentURI\n     * 2. Fetch document from documentURI (IPFS, HTTP, etc.)\n     * 3. Hash the fetched document (SHA-256)\n     * 4. Compare: fetched hash == documentHash?\n     *    - If YES → Document is authentic ✓\n     *    - If NO → Document was tampered with ✗\n     * \n     * WHY THIS FUNCTION:\n     * - Enables verifiers to resolve issuer DIDs\n     * - Allows checking DID ownership\n     * - Provides ALL information needed for complete resolution\n     * - documentURI solves the \"where to fetch\" problem you identified!\n     * \n     * GAS COST: ~2,100 gas (warm storage read)\n     */\n    function resolveDID(string memory did)\n        external\n        view\n        returns (\n            address controller,\n            bytes32 documentHash,\n            string memory documentURI,\n            uint256 registeredAt,\n            uint256 updatedAt\n        )\n    {\n        // WHY CHECK: Return zero values if DID doesn't exist\n        // This allows callers to check if DID exists\n        DIDRecord memory record = _dids[did];\n        \n        return (\n            record.controller,\n            record.documentHash,\n            record.documentURI,\n            record.registeredAt,\n            record.updatedAt\n        );\n    }\n\n    /**\n     * @notice Gets the DID controlled by an address\n     * @param controller The address to look up\n     * @return did The DID controlled by this address (empty if none)\n     * \n     * WHY THIS FUNCTION:\n     * - Frontend: \"What's my DID?\"\n     * - Reverse lookup: Address -> DID\n     * - Useful for wallet integrations\n     * \n     * NOTE: Returns empty string if address has no DID\n     */\n    function getDIDByController(address controller)\n        external\n        view\n        returns (string memory)\n    {\n        return _controllerToDID[controller];\n    }\n\n    /**\n     * @notice Checks if a DID exists\n     * @param did The DID to check\n     * @return exists True if DID is registered, false otherwise\n     * \n     * WHY THIS FUNCTION:\n     * - Simple boolean check (more gas efficient than full resolution)\n     * - Useful for validation before operations\n     * - Clearer intent than checking controller != address(0)\n     */\n    function didExists(string memory did) external view returns (bool) {\n        return _dids[did].controller != address(0);\n    }\n\n    /**\n     * @notice Checks if an address controls a DID\n     * @param controller The address to check\n     * @return hasDID True if address controls a DID, false otherwise\n     * \n     * WHY THIS FUNCTION:\n     * - Quick check before registration\n     * - Useful for UI state management\n     * - More readable than checking getDIDByController result\n     */\n    function hasDID(address controller) external view returns (bool) {\n        return bytes(_controllerToDID[controller]).length > 0;\n    }\n}\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "*",
          "evm.bytecode.object",
          "evm.deployedBytecode.object",
          "metadata",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "evmVersion": "paris",
    "metadata": {
      "useLiteralContent": true
    }
  }
}