import { resolve } from 'node:path'
import { promises as fs } from 'node:fs'
import { config as loadEnv } from 'dotenv'
import { task, type HardhatUserConfig } from 'hardhat/config'
import type { BuildInfo, HardhatRuntimeEnvironment } from 'hardhat/types'
import { docgen as runDocgen } from 'solidity-docgen'

import '@nomicfoundation/hardhat-toolbox'
import '@typechain/hardhat'
import 'hardhat-deploy'
import 'hardhat-gas-reporter'
import 'hardhat-contract-sizer'
import '@openzeppelin/hardhat-upgrades'

loadEnv({ path: resolve(__dirname, '.env.hardhat.local') })

const privateKey = process.env.PRIVATE_KEY?.trim()
const mnemonic = process.env.MNEMONIC?.trim()
const accounts: any = privateKey ? [privateKey] : mnemonic ? { mnemonic } : undefined
// Auto doc generation runs post-compile unless DOCS_AUTOGEN=false is set
const docsAutogenEnv = process.env.DOCS_AUTOGEN?.toLowerCase()
const shouldAutoGenerateDocs = docsAutogenEnv !== 'false'

// Reuse the most recent Solc build outputs to generate Markdown docs without recompiling
async function generateDocs(hre: HardhatRuntimeEnvironment) {
  const buildInfoPaths = await hre.artifacts.getBuildInfoPaths()
  if (buildInfoPaths.length === 0) return

  const builds = await Promise.all(
    buildInfoPaths.map(async buildInfoPath => {
      const contents = await fs.readFile(buildInfoPath, 'utf8')
      const buildInfo = JSON.parse(contents) as BuildInfo
      return { input: buildInfo.input, output: buildInfo.output }
    })
  )

  await runDocgen(builds, hre.config.docgen)
}

task('compile').setAction(async (args, hre, runSuper) => {
  const result = await runSuper(args)
  if (shouldAutoGenerateDocs) await generateDocs(hre)
  return result
})

const config: HardhatUserConfig = {
  solidity: { 
    version: '0.8.28', 
    settings: { 
      optimizer: { enabled: true, runs: 200 },
      outputSelection: {
        '*': {
          '*': ['*', 'evm.bytecode.object', 'evm.deployedBytecode.object', 'metadata']
        }
      }
    } 
  },
  defaultNetwork: 'hardhat',
  networks: {
    hardhat: {},
    ...(process.env.SEPOLIA_RPC ? { sepolia: { url: process.env.SEPOLIA_RPC!, accounts } } : {}),
    // Optional alias network to use Blockscout endpoints for verification while reusing Sepolia RPC
    ...(process.env.SEPOLIA_RPC ? { 'sepolia-blockscout': { url: process.env.SEPOLIA_RPC!, accounts } } : {}),
    ...(process.env.MAINNET_RPC ? { mainnet: { url: process.env.MAINNET_RPC!, accounts } } : {}),
    ...(process.env.POLYGON_RPC ? { polygon: { url: process.env.POLYGON_RPC!, accounts } } : {}),
    ...(process.env.OPTIMISM_RPC ? { optimism: { url: process.env.OPTIMISM_RPC!, accounts } } : {}),
    ...(process.env.ARBITRUM_RPC ? { arbitrum: { url: process.env.ARBITRUM_RPC!, accounts } } : {})
  },
  namedAccounts: { deployer: { default: 0 } },
  gasReporter: { enabled: true, currency: 'USD' },
  contractSizer: { runOnCompile: true },
  docgen: {
    outputDir: 'docs',
    pages: 'files',
    theme: 'markdown',
    collapseNewlines: true
  },
  paths: {
    sources: resolve(__dirname, 'contracts'),
    tests: resolve(__dirname, 'test'),
    cache: resolve(__dirname, 'cache'),
    artifacts: resolve(__dirname, '../../apps/dao-dapp/src/contracts')
  },
  etherscan: {
    apiKey: {
      // Blockscout generally ignores API keys; placeholder keeps verify plugin happy
      'sepolia-blockscout': 'dummy'
    },
    customChains: [
      {
        network: 'sepolia-blockscout',
        chainId: 11155111,
        urls: {
          apiURL: 'https://eth-sepolia.blockscout.com/api',
          browserURL: 'https://eth-sepolia.blockscout.com'
        }
      }
    ]
  }
}
export default config
